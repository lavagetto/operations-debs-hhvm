From 2eb7a84d0f742c75c5def69423e1d653a27e0236 Mon Sep 17 00:00:00 2001
From: Tim Starling <tstarling@wikimedia.org>
Date: Tue, 24 Jun 2014 11:19:07 +1000
Subject: [PATCH] Support stream wrappers in XML parser extensions

Closes: #2829
---
 hphp/runtime/ext/ext_simplexml.cpp     |   3 +
 hphp/runtime/ext/ext_xml.cpp           |   2 +-
 hphp/runtime/ext/ext_xmlreader.cpp     |  16 ++++
 hphp/runtime/ext/libxml/ext_libxml.cpp | 161 +++++++++++++++++++++++++++++++--
 hphp/runtime/ext/libxml/ext_libxml.php |   4 +
 5 files changed, 176 insertions(+), 10 deletions(-)

--- a/hphp/runtime/ext/ext_simplexml.cpp
+++ b/hphp/runtime/ext/ext_simplexml.cpp
@@ -21,6 +21,7 @@
 #include "hphp/runtime/ext/ext_domdocument.h"
 #include "hphp/runtime/base/class-info.h"
 #include "hphp/system/systemlib.h"
+#include "hphp/runtime/vm/vm-regs.h"
 
 namespace HPHP {
 
@@ -1122,6 +1123,7 @@ Variant f_simplexml_load_string(
   int64_t options /* = 0 */,
   const String& ns /* = "" */,
   bool is_prefix /* = false */) {
+  SYNC_VM_REGS_SCOPED();
   Class* cls = class_from_name(class_name, "simplexml_load_string");
   if (!cls) {
     return init_null();
@@ -1192,6 +1194,7 @@ void c_SimpleXMLElement::t___construct(c
                                        bool data_is_url /* = false */,
                                        const String& ns /* = "" */,
                                        bool is_prefix /* = false */) {
+  SYNC_VM_REGS_SCOPED();
   xmlDocPtr docp = data_is_url ?
     xmlReadFile(data.data(), nullptr, options) :
     xmlReadMemory(data.data(), data.size(), nullptr, nullptr, options);
--- a/hphp/runtime/ext/ext_xml.cpp
+++ b/hphp/runtime/ext/ext_xml.cpp
@@ -717,8 +717,8 @@ int64_t f_xml_parse(const Resource& pars
 
 int64_t f_xml_parse_into_struct(const Resource& parser, const String& data, VRefParam values,
                             VRefParam index /* = null */) {
+  SYNC_VM_REGS_SCOPED();
   int ret;
-  VMRegAnchor _;
   XmlParser * p = parser.getTyped<XmlParser>();
   values = Array::Create();
   p->data.assignRef(values);
--- a/hphp/runtime/ext/ext_xmlreader.cpp
+++ b/hphp/runtime/ext/ext_xmlreader.cpp
@@ -22,6 +22,7 @@
 #include "hphp/util/functional.h"
 #include "hphp/util/hash-map-typedefs.h"
 #include "hphp/system/systemlib.h"
+#include "hphp/runtime/vm/vm-regs.h"
 
 namespace HPHP {
 
@@ -139,6 +140,7 @@ void c_XMLReader::t___construct() {
 }
 
 bool c_XMLReader::t_open(const String& uri, const String& encoding /*= null_string*/, int64_t options /*= 0*/) {
+  SYNC_VM_REGS_SCOPED();
   if (m_ptr) {
     t_close();
   }
@@ -211,6 +213,7 @@ bool c_XMLReader::t_xml(const String& so
 }
 
 void c_XMLReader::close_impl() {
+  SYNC_VM_REGS_SCOPED();
   if (m_ptr) {
     xmlFreeTextReader(m_ptr);
     m_ptr = NULL;
@@ -231,6 +234,7 @@ bool c_XMLReader::t_close() {
 }
 
 bool c_XMLReader::t_read() {
+  SYNC_VM_REGS_SCOPED();
   if (m_ptr) {
     int ret = xmlTextReaderRead(m_ptr);
     if (ret == -1) {
@@ -245,6 +249,7 @@ bool c_XMLReader::t_read() {
 }
 
 bool c_XMLReader::t_next(const String& localname /*= null_string*/) {
+  SYNC_VM_REGS_SCOPED();
   if (m_ptr) {
     int ret = xmlTextReaderNext(m_ptr);
     while (!localname.empty() && ret == 1) {
@@ -265,6 +270,7 @@ bool c_XMLReader::t_next(const String& l
 }
 
 String c_XMLReader::read_string_func(xmlreader_read_char_t internal_function) {
+  SYNC_VM_REGS_SCOPED();
   char *retchar = NULL;
   if (m_ptr) {
     retchar = (char *)internal_function(m_ptr);
@@ -291,6 +297,7 @@ String c_XMLReader::t_readouterxml() {
 }
 
 bool c_XMLReader::bool_func_no_arg(xmlreader_read_int_t internal_function) {
+  SYNC_VM_REGS_SCOPED();
   if (m_ptr) {
     int ret = internal_function(m_ptr);
     if (ret == 1) {
@@ -301,6 +308,7 @@ bool c_XMLReader::bool_func_no_arg(xmlre
 }
 
 Variant c_XMLReader::string_func_string_arg(String value, xmlreader_read_one_char_t internal_function) {
+  SYNC_VM_REGS_SCOPED();
 
   if (value.empty()) {
     raise_warning("Argument cannot be an empty string");
@@ -326,6 +334,7 @@ Variant c_XMLReader::t_getattribute(cons
 }
 
 Variant c_XMLReader::t_getattributeno(int64_t index) {
+  SYNC_VM_REGS_SCOPED();
   char *retchar = NULL;
   if (m_ptr) {
     retchar = (char *)xmlTextReaderGetAttributeNo(m_ptr, index);
@@ -340,6 +349,7 @@ Variant c_XMLReader::t_getattributeno(in
 }
 
 Variant c_XMLReader::t_getattributens(const String& name, const String& namespaceURI) {
+  SYNC_VM_REGS_SCOPED();
   if (name.empty() || namespaceURI.empty()) {
     raise_warning("Attribute Name and Namespace URI cannot be empty");
     return false;
@@ -362,6 +372,7 @@ Variant c_XMLReader::t_getattributens(co
 }
 
 bool c_XMLReader::t_movetoattribute(const String& name) {
+  SYNC_VM_REGS_SCOPED();
   if (name.empty()) {
     raise_warning("Attribute Name is required");
     return false;
@@ -377,6 +388,7 @@ bool c_XMLReader::t_movetoattribute(cons
 }
 
 bool c_XMLReader::t_movetoattributeno(int64_t index) {
+  SYNC_VM_REGS_SCOPED();
   if (m_ptr) {
     int ret = xmlTextReaderMoveToAttributeNo(m_ptr, index);
     if (ret == 1) {
@@ -387,6 +399,7 @@ bool c_XMLReader::t_movetoattributeno(in
 }
 
 bool c_XMLReader::t_movetoattributens(const String& name, const String& namespaceURI) {
+  SYNC_VM_REGS_SCOPED();
   if (name.empty() || namespaceURI.empty()) {
     raise_warning("Attribute Name and Namespace URI cannot be empty");
     return false;
@@ -435,6 +448,7 @@ Variant c_XMLReader::t_lookupnamespace(c
 }
 
 bool c_XMLReader::t_setschema(const String& source) {
+  SYNC_VM_REGS_SCOPED();
   if (source.empty()) {
     raise_warning("Schema data source is required");
     return false;
@@ -463,6 +477,7 @@ bool c_XMLReader::t_setparserproperty(in
 }
 
 bool c_XMLReader::set_relaxng_schema(String source, int type) {
+  SYNC_VM_REGS_SCOPED();
   if (source.empty()) {
     raise_warning("Schema data source is required");
     return false;
@@ -609,6 +624,7 @@ Variant c_XMLReader::t___get(Variant nam
 Variant c_XMLReader::t_expand(const Object& basenode /* = null */) {
   p_DOMDocument doc;
   xmlDocPtr docp = nullptr;
+  SYNC_VM_REGS_SCOPED();
 
   if (!basenode.isNull()) {
     c_DOMNode *dombasenode = basenode.getTyped<c_DOMNode>();
--- a/hphp/runtime/ext/libxml/ext_libxml.cpp
+++ b/hphp/runtime/ext/libxml/ext_libxml.cpp
@@ -16,8 +16,12 @@
 */
 
 #include "hphp/runtime/ext/libxml/ext_libxml.h"
+#include "hphp/runtime/ext/ext_file.h"
 #include "hphp/runtime/base/request-local.h"
 #include "hphp/runtime/base/request-event-handler.h"
+#include "hphp/runtime/base/stream-wrapper-registry.h"
+#include "hphp/runtime/base/file-stream-wrapper.h"
+#include "hphp/runtime/base/file.h"
 
 #include <libxml/parser.h>
 #include <libxml/parserInternals.h>
@@ -30,10 +34,24 @@
 #include <libxml/xmlschemas.h>
 #endif
 
+#include <memory>
+#include <cstring>
+
 namespace HPHP {
+///////////////////////////////////////////////////////////////////////////////
 
 static xmlParserInputBufferPtr
-libxml_input_buffer(const char *URI, xmlCharEncoding enc);
+libxml_create_input_buffer(const char *URI, xmlCharEncoding enc);
+
+static xmlOutputBufferPtr
+libxml_create_output_buffer(const char *URI,
+  xmlCharEncodingHandlerPtr encoder, int compression ATTRIBUTE_UNUSED);
+
+static Resource libxml_streams_IO_open_wrapper(
+    const char *filename, const char* mode, bool read_only);
+static int libxml_streams_IO_read(void *context, char *buffer, int len);
+static int libxml_streams_IO_write(void *context, const char *buffer, int len);
+static int libxml_streams_IO_close(void *context);
 
 class xmlErrorVec : public std::vector<xmlError> {
 public:
@@ -59,16 +77,19 @@ struct LibXmlRequestData final : Request
     m_use_error = false;
     m_errors.reset();
     m_entity_loader_disabled = false;
+    m_streams_context = uninit_null();
   }
 
   void requestShutdown() override {
     m_use_error = false;
     m_errors.reset();
+    m_streams_context = uninit_null();
   }
 
   bool m_entity_loader_disabled;
   bool m_use_error;
   xmlErrorVec m_errors;
+  Variant m_streams_context;
 };
 
 IMPLEMENT_STATIC_REQUEST_LOCAL(LibXmlRequestData, tl_libxml_request_data);
@@ -197,22 +218,143 @@ bool HHVM_FUNCTION(libxml_use_internal_e
   return ret;
 }
 
+bool HHVM_FUNCTION(libxml_disable_entity_loader, bool disable /* = true */) {
+  bool old = tl_libxml_request_data->m_entity_loader_disabled;
+
+  tl_libxml_request_data->m_entity_loader_disabled = disable;
+
+  return old;
+}
+
+void HHVM_FUNCTION(libxml_set_streams_context, const Resource & context) {
+  tl_libxml_request_data->m_streams_context = context;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// Callbacks
+//
+// Note that these stream callbacks may re-enter the VM via a user-defined
+// stream wrapper. The VM state should be synced using VMRegAnchor by the
+// caller, before entering libxml2.
+
+static Resource libxml_streams_IO_open_wrapper(
+    const char *filename, const char* mode, bool read_only)
+{
+  String strFilename = StringData::Make(filename, CopyString);
+  /* FIXME: PHP calls stat() here if the wrapper has a non-null stat handler,
+   * in order to skip the open of a missing file, thus suppressing warnings.
+   * Our stat handlers are virtual, so there's no easy way to tell if stat
+   * is supported, so instead we will just call stat() for plain files, since
+   * of the default transports, only plain files have support for stat().
+   */
+  if (read_only) {
+    int pathIndex = 0;
+    Stream::Wrapper * wrapper = Stream::getWrapperFromURI(strFilename, &pathIndex);
+    if (dynamic_cast<FileStreamWrapper*>(wrapper)) {
+      if (!f_file_exists(strFilename)) {
+        return Resource();
+      }
+    }
+  }
+
+  // PHP unescapes the URI here, but that should properly be done by the wrapper.
+  // The wrapper should expect a valid URI, e.g. file:///foo%20bar
+  return File::Open(strFilename, mode, 0,
+      tl_libxml_request_data->m_streams_context);
+}
+
+static int libxml_streams_IO_read(void *context, char *buffer, int len) {
+  Resource stream = (ResourceData*)context;
+  assert(len >= 0);
+  Variant ret = f_fread(stream, len);
+  if (ret.is(KindOfString)) {
+    const String & str = ret.asCStrRef();
+    if (str.size() <= len) {
+      std::memcpy(buffer, str.data(), str.size());
+      return str.size();
+    } else {
+      return -1;
+    }
+  } else {
+    return -1;
+  }
+}
+
+static int libxml_streams_IO_write(void *context, const char *buffer, int len) {
+  Resource stream = (ResourceData*)context;
+  String strBuffer = StringData::Make(buffer, len, CopyString);
+  Variant ret = f_fwrite(stream, strBuffer);
+  if (ret.is(KindOfInt64) && ret.asInt64Val() < INT_MAX) {
+    return (int)ret.asInt64Val();
+  } else {
+    return -1;
+  }
+}
+
+static int libxml_streams_IO_close(void *context) {
+  Resource stream = (ResourceData*)context;
+  int ret = f_fclose(stream) ? 0 : -1;
+  stream.get()->decRefAndRelease();
+  return ret;
+}
+
 static xmlParserInputBufferPtr
-libxml_input_buffer(const char *URI, xmlCharEncoding enc) {
+libxml_create_input_buffer(const char *URI, xmlCharEncoding enc) {
   if (tl_libxml_request_data->m_entity_loader_disabled) {
     return nullptr;
   }
-  return __xmlParserInputBufferCreateFilename(URI, enc);
-}
 
-bool HHVM_FUNCTION(libxml_disable_entity_loader, bool disable /* = true */) {
-  bool old = tl_libxml_request_data->m_entity_loader_disabled;
+  if (URI == nullptr) {
+    return nullptr;
+  }
 
-  tl_libxml_request_data->m_entity_loader_disabled = disable;
+  Resource stream = libxml_streams_IO_open_wrapper(URI, "rb", true);
 
-  return old;
+  if (stream.isInvalid()) {
+    return nullptr;
+  }
+
+  // Allocate the Input buffer front-end.
+  xmlParserInputBufferPtr ret = xmlAllocParserInputBuffer(enc);
+  if (ret != nullptr) {
+    stream.get()->incRefCount();
+    ret->context = (void*)stream.get();
+    ret->readcallback = libxml_streams_IO_read;
+    ret->closecallback = libxml_streams_IO_close;
+  }
+
+  return ret;
 }
 
+static xmlOutputBufferPtr
+libxml_create_output_buffer(const char *URI,
+                              xmlCharEncodingHandlerPtr encoder,
+                              int compression ATTRIBUTE_UNUSED)
+{
+  if (URI == nullptr) {
+    return nullptr;
+  }
+  // PHP unescapes the URI here, but that should properly be done by the wrapper.
+  // The wrapper should expect a valid URI, e.g. file:///foo%20bar
+  Resource stream = libxml_streams_IO_open_wrapper(URI, "wb", false);
+  if (stream.isInvalid()) {
+    return nullptr;
+  }
+  // Allocate the Output buffer front-end.
+  xmlOutputBufferPtr ret = xmlAllocOutputBuffer(encoder);
+  if (ret != nullptr) {
+    stream.get()->incRefCount();
+    ret->context = (void*)stream.get();
+    ret->writecallback = libxml_streams_IO_write;
+    ret->closecallback = libxml_streams_IO_close;
+  }
+
+  return ret;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// Extension
+
 class LibXMLExtension : public Extension {
   public:
     LibXMLExtension() : Extension("libxml") {}
@@ -280,7 +422,8 @@ class LibXMLExtension : public Extension
       loadSystemlib();
 
       s_LibXMLError_class = Unit::lookupClass(s_LibXMLError.get());
-      xmlParserInputBufferCreateFilenameDefault(libxml_input_buffer);
+      xmlParserInputBufferCreateFilenameDefault(libxml_create_input_buffer);
+      xmlOutputBufferCreateFilenameDefault(libxml_create_output_buffer);
     }
 
     void requestInit() override {
--- a/hphp/runtime/ext/libxml/ext_libxml.php
+++ b/hphp/runtime/ext/libxml/ext_libxml.php
@@ -30,3 +30,7 @@ function libxml_use_internal_errors(bool
 /* Disable/enable the ability to load external entities. */
 <<__Native>>
 function libxml_disable_entity_loader(bool $disable = true): bool;
+
+/* Set the streams context for the next libxml document load or write */
+<<__Native>>
+function libxml_set_streams_context(resource $context): void;
