From 90c41505bc8efe5f95d0c20ed6dd7c9420ee1f2e Mon Sep 17 00:00:00 2001
From: Tim Starling <tstarling@wikimedia.org>
Date: Mon, 22 Sep 2014 14:51:38 +1000
Subject: [PATCH] EZC: Fix count() and conversion to boolean of ProxyArray

Fix JIT versions of count() and conversion of array to boolean, so
that they work with ProxyArray. In both cases, duplicate the logic in
ArrayData::size() -- if the sign bit of the size field is unset, use
that field, otherwise call vsize().

The resulting generated machine code for conversion to boolean is along
the lines of:

  mov    0x4(%rdi),%eax
  test   %eax,%eax
  js     0xf80049b
  setne  %al

where 0xf80049b is the slow path. This is similar to the machine code I
previously reported for ArrayData::size() in code review of 1717e028f18
(see #3065).

Added test case which previously failed.
---
--- a/hphp/runtime/base/array-data.h
+++ b/hphp/runtime/base/array-data.h
@@ -123,7 +123,7 @@ struct ArrayData {
 
   // unlike ArrayData::size(), this functions doesn't delegate
   // to the vsize() function, so its more efficient to use this when
-  // you know you don't have a NameValueTableWrapper.
+  // you know you don't have a NameValueTableWrapper or ProxyArray
   size_t getSize() const {
     return m_size;
   }
diff --git a/hphp/runtime/base/tv-helpers.cpp b/hphp/runtime/base/tv-helpers.cpp
index 76169bd..a9a45db 100644
--- a/hphp/runtime/base/tv-helpers.cpp
+++ b/hphp/runtime/base/tv-helpers.cpp
@@ -111,9 +111,7 @@ void tvCastToBooleanInPlace(TypedValue* tv) {
   case KindOfDouble:  b = (tv->m_data.dbl != 0); break;
   case KindOfStaticString: b = tv->m_data.pstr->toBoolean(); break;
   case KindOfString:  b = tv->m_data.pstr->toBoolean(); tvDecRefStr(tv); break;
-  // Note that this is intentionally incorrect for NameValueTableWrapper, for
-  // which getSize() will always return -1, empty or not.
-  case KindOfArray:   b = !!tv->m_data.parr->getSize();
+  case KindOfArray:   b = !!tv->m_data.parr->size();
                       tvDecRefArr(tv);
                       break;
   case KindOfObject:  b = tv->m_data.pobj->o_toBoolean();
--- a/hphp/runtime/vm/jit/code-gen-x64.cpp
+++ b/hphp/runtime/vm/jit/code-gen-x64.cpp
@@ -172,6 +172,26 @@ void CodeGenerator::unlikelyIfThenElse(Vout& v, Vout& vcold, ConditionCode cc,
   v = done;
 }
 
+// emit an if-then-else condition where the true case is unlikely.
+template <class T, class F>
+Vreg unlikelyCond(Vout& v, Vout& vc, ConditionCode cc, Vreg d, T t, F f) {
+    auto fblock = v.makeBlock();
+    auto tblock = vc.makeBlock();
+    auto done = v.makeBlock();
+    v << jcc{cc, {fblock, tblock}};
+    vc = tblock;
+    auto treg = t(vc);
+    vc << phijmp{done, vc.makeTuple(VregList{treg})};
+    v = fblock;
+    auto freg = f(v);
+    v << phijmp{done, v.makeTuple(VregList{freg})};
+    v = done;
+    v << phidef{v.makeTuple(VregList{d})};
+    return d;
+}
+
+
+
 /*
  * Generate an if-block that branches around some unlikely code, handling
  * the cases when a == astubs and a != astubs.  cc is the branch condition
@@ -2317,11 +2337,27 @@ void CodeGenerator::cgConvArrToBool(IRInstruction* inst) {
   auto srcReg = srcLoc(0).reg();
   auto& v = vmain();
 
-  // This will incorrectly result in "true" for a NameValueTableWrapper that is
-  // empty. You can only get such a thing through very contrived PHP, so the
-  // savings of a branch and a block of cold code outweights the edge-case bug.
-  v << cmplim{0, srcReg[ArrayData::offsetofSize()]};
-  v << setcc{CC_NZ, dstReg};
+  auto size = v.makeReg();
+  v << loadl{srcReg[ArrayData::offsetofSize()], size};
+  v << testl{size, size};
+
+  unlikelyCond(v, vcold(), CC_S, dstReg,
+    [&](Vout& v) {
+      auto vsize = v.makeReg();
+      auto dst1 = v.makeReg();
+      cgCallHelper(v, CppCall::method(&ArrayData::vsize),
+                   callDest(vsize), SyncOptions::kNoSyncPoint,
+                   argGroup().ssa(0));
+      v << testl{vsize, vsize};
+      v << setcc{CC_NZ, dst1};
+      return dst1;
+    },
+    [&](Vout& v) {
+      auto dst2 = v.makeReg();
+      v << setcc{CC_NZ, dst2};
+      return dst2;
+    }
+  );
 }
 
 /*
@@ -6203,14 +6239,21 @@ void CodeGenerator::cgCountArray(IRInstruction* inst) {
   auto const baseReg = srcLoc(0).reg();
   auto const dstReg  = dstLoc(0).reg();
   auto& v = vmain();
+  auto dst1 = v.makeReg();
+
+  v << loadl{baseReg[ArrayData::offsetofSize()], dst1};
+  v << testl{dst1, dst1};
 
-  v << cmpbim{ArrayData::kNvtwKind, baseReg[ArrayData::offsetofKind()]};
-  unlikelyIfThenElse(v, vcold(), CC_Z,
+  unlikelyCond(v, vcold(), CC_S, dstReg,
     [&](Vout& v) {
-      cgCallNative(v, inst);
+      auto dst2 = v.makeReg();
+      cgCallHelper(v, CppCall::method(&ArrayData::vsize),
+                   callDest(dst2), SyncOptions::kNoSyncPoint,
+                   argGroup().ssa(0/*base*/));
+      return dst2;
     },
     [&](Vout& v) {
-      v << loadl{baseReg[ArrayData::offsetofSize()], dstReg};
+       return dst1;
     }
   );
 }
--- a/hphp/runtime/vm/jit/ir.h
+++ b/hphp/runtime/vm/jit/ir.h
@@ -260,7 +260,7 @@ O(ConvObjToArr,                 D(Arr), S(Obj),               Er|N|PRc|CRc|K) \
 O(ConvStrToArr,                 D(Arr), S(Str),                  NNT|PRc|CRc) \
 O(ConvCellToArr,                D(Arr), S(Cell),              Er|N|PRc|CRc|K) \
                                                                               \
-O(ConvArrToBool,               D(Bool), S(Arr),                           NF) \
+O(ConvArrToBool,               D(Bool), S(Arr),                          NNT) \
 O(ConvDblToBool,               D(Bool), S(Dbl),                            C) \
 O(ConvIntToBool,               D(Bool), S(Int),                            C) \
 O(ConvStrToBool,               D(Bool), S(Str),                          NNT) \
--- a/hphp/test/slow/array/empty-globals.php
+++ b/hphp/test/slow/array/empty-globals.php
@@ -6,7 +6,6 @@ function main() {
   }
 
   var_dump($g);
-  // This will say "true", which is intentionally divergent from PHP5.
   var_dump((bool)$g);
 }
 
diff --git a/hphp/test/slow/array/empty-globals.php.expect b/hphp/test/slow/array/empty-globals.php.expect
index e94c5a1..bce0d38 100644
--- a/hphp/test/slow/array/empty-globals.php.expect
+++ b/hphp/test/slow/array/empty-globals.php.expect
@@ -1,3 +1,3 @@
 array(0) {
 }
-bool(true)
+bool(false)
--- /dev/null
+++ b/hphp/test/slow/ext_ezc_test/count-proxyarray.php
@@ -0,0 +1,12 @@
+<?php
+
+// Ensure that count() and conversion to boolean work with proxy arrays
+
+$x = ezc_create_cloneable_in_array();
+print count($x) . "\n";
+ezc_call(
+	function( $x ) {
+		print $x ? "true\n" : "false\n";
+	},
+	array()
+);
--- /dev/null
+++ b/hphp/test/slow/ext_ezc_test/count-proxyarray.php.expectf
@@ -0,0 +1,2 @@
+1
+false
