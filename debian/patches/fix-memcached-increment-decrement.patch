Description: workaround to make Memcached::increment & Memcached::decrement work.
 We weren't correctly dispatching to the right memcached_* function,
 causing it to always fail when using the ascii protocol. There's
 still one divergence from PHP5: if an initial_value is given but the
 connection is using the acsii protocol, PHP will raise a warning and
 return false, but we'll silently ignore the initial value and continue on with the increment.
Author: Brett Simmers <bsimmers@fb.com>
Forwarded: No
Last-Updated: 20140925

--- /dev/null
+++ b/hphp/test/slow/ext_memcached/inc_dec.php
@@ -0,0 +1,10 @@
+<?php
+const key = 'incr_decr_test';
+$mc = new Memcached;
+$mc->addServer('127.0.0.1', 11211);
+$mc->set(key, 0);
+var_dump($mc->get(key));
+$mc->increment(key, 3);
+var_dump($mc->get( key));
+$mc->decrement(key, 1);
+var_dump($mc->get(key));
--- /dev/null
+++ b/hphp/test/slow/ext_memcached/inc_dec.php.expect
@@ -0,0 +1,3 @@
+int(0)
+int(3)
+int(2)
--- /dev/null
+++ b/hphp/test/slow/ext_memcached/inc_dec.php.skipif
@@ -0,0 +1,8 @@
+<?php
+
+$memc = new Memcached();
+$memc->addServer('localhost', '11211');
+$version = $memc->getVersion();
+if (!$version) {
+  echo "SKIP No Memcached running";
+}
--- a/hphp/runtime/ext/memcached/ext_memcached.cpp
+++ b/hphp/runtime/ext/memcached/ext_memcached.cpp
@@ -461,15 +461,12 @@ class MemcachedData {
                           myServerKey.length(), key.c_str(), key.length(),
                           payload.data(), payload.size(), expiration, flags));
   }
-  typedef memcached_return_t (*IncDecOperation)(memcached_st *, const char *,
-      size_t, const char *, size_t, uint64_t, uint64_t, time_t, uint64_t *);
-  Variant incDecOperationImpl(IncDecOperation op, const String& server_key,
-                                                  const String& key,
-                                                  int64_t offset,
-                                                  int64_t inital_value,
-                                                  int64_t expiry) {
+
+  Variant incDecOp(bool isInc,
+                   const StringData* server_key, const StringData* key,
+                   int64_t offset, int64_t initial_value, int64_t expiry) {
     m_impl->rescode = q_Memcached$$RES_SUCCESS;
-    if (key.empty()) {
+    if (key->empty() || strchr(key->data(), ' ')) {
       m_impl->rescode = q_Memcached$$RES_BAD_KEY_PROVIDED;
       return false;
     }
@@ -478,17 +475,77 @@ class MemcachedData {
       return false;
     }
 
+    // Dispatch to the correct memcached_* function depending on initial_value,
+    // server_key, and isInc.
     uint64_t value;
-    const String& myServerKey = server_key.empty() ? key : server_key;
-    if (!handleError(op(&m_impl->memcached, myServerKey.c_str(),
-                        myServerKey.length(), key.c_str(), key.length(),
-                        (uint32_t)offset, (uint32_t)inital_value,
-                        (uint32_t)expiry, &value))) {
-      return false;
+    memcached_return_t status;
+
+    // XXX(#3862): use_initial should really depend on the number of arguments
+    // passed to the function but this isn't currently supported by HNI.
+    bool use_initial = isBinaryProtocol();
+    auto mc = &m_impl->memcached;
+    if (use_initial) {
+      if (!isBinaryProtocol()) {
+        raise_warning("Initial value is only supported with binary protocol");
+        return false;
+      }
+
+      if (server_key) {
+        if (isInc) {
+          status = memcached_increment_with_initial_by_key(
+            mc,
+            server_key->data(), server_key->size(), key->data(), key->size(),
+            offset, initial_value, expiry, &value);
+        } else {
+          status = memcached_decrement_with_initial_by_key(
+            mc,
+            server_key->data(), server_key->size(), key->data(), key->size(),
+            offset, initial_value, expiry, &value);
+        }
+      } else {
+        if (isInc) {
+          status = memcached_increment_with_initial(
+            mc, key->data(), key->size(),
+            offset, initial_value, expiry, &value);
+        } else {
+          status = memcached_decrement_with_initial(
+            mc, key->data(), key->size(),
+            offset, initial_value, expiry, &value);
+        }
+      }
+    } else {
+      if (server_key) {
+        if (isInc) {
+          status = memcached_increment_by_key(
+            mc,
+            server_key->data(), server_key->size(), key->data(), key->size(),
+            offset, &value);
+        } else {
+          status = memcached_decrement_by_key(
+            mc,
+            server_key->data(), server_key->size(), key->data(), key->size(),
+            offset, &value);
+        }
+      } else {
+        if (isInc) {
+          status = memcached_increment(
+            mc, key->data(), key->size(), offset, &value);
+        } else {
+          status = memcached_decrement(
+            mc, key->data(), key->size(), offset, &value);
+        }
+      }
     }
+
+    if (!handleError(status)) return false;
     return (int64_t)value;
   }
 
+  bool isBinaryProtocol() {
+    return memcached_behavior_get(&m_impl->memcached,
+                                  MEMCACHED_BEHAVIOR_BINARY_PROTOCOL);
+  }
+
   typedef std::map<std::string, ImplPtr> ImplMap;
   static DECLARE_THREAD_LOCAL(ImplMap, s_persistentMap);
 };
@@ -741,24 +798,42 @@ bool HHVM_METHOD(Memcached, deletebykey, const String& server_key,
                      key.c_str(), key.length(), time));
 }
 
-Variant HHVM_METHOD(Memcached, incrementbykey, const String& server_key,
-                                               const String& key,
-                                               int64_t offset /*= 1*/,
-                                               int64_t inital_value /*= 0*/,
-                                               int64_t expiry /*= 0*/) {
-  auto data = Native::data<MemcachedData>(this_);
-  return data->incDecOperationImpl(memcached_increment_with_initial_by_key,
-                                server_key, key, offset, inital_value, expiry);
+Variant HHVM_METHOD(Memcached, increment,
+                    const String& key,
+                    int64_t offset /* = 1 */,
+                    int64_t initial_value /* = 0 */,
+                    int64_t expiry /* = 0 */) {
+  return Native::data<MemcachedData>(this_)->incDecOp(
+    true, nullptr, key.get(), offset, initial_value, expiry);
 }
 
-Variant HHVM_METHOD(Memcached, decrementbykey, const String& server_key,
-                                               const String& key,
-                                               int64_t offset /*= 1*/,
-                                               int64_t inital_value /*= 0*/,
-                                               int64_t expiry /*= 0*/) {
-  auto data = Native::data<MemcachedData>(this_);
-  return data->incDecOperationImpl(memcached_decrement_with_initial_by_key,
-                                server_key, key, offset, inital_value, expiry);
+Variant HHVM_METHOD(Memcached, incrementbykey,
+                    const String& server_key,
+                    const String& key,
+                    int64_t offset /* = 1 */,
+                    int64_t initial_value /* = 0 */,
+                    int64_t expiry /* = 0 */) {
+  return Native::data<MemcachedData>(this_)->incDecOp(
+    true, server_key.get(), key.get(), offset, initial_value, expiry);
+}
+
+Variant HHVM_METHOD(Memcached, decrement,
+                    const String& key,
+                    int64_t offset /* = 1 */,
+                    int64_t initial_value /* = 0 */,
+                    int64_t expiry /* = 0 */) {
+  return Native::data<MemcachedData>(this_)->incDecOp(
+    false, nullptr, key.get(), offset, initial_value, expiry);
+}
+
+Variant HHVM_METHOD(Memcached, decrementbykey,
+                    const String& server_key,
+                    const String& key,
+                    int64_t offset /* = 1 */,
+                    int64_t initial_value /* = 0 */,
+                    int64_t expiry /* = 0 */) {
+  return Native::data<MemcachedData>(this_)->incDecOp(
+    false, server_key.get(), key.get(), offset, initial_value, expiry);
 }
 
 bool HHVM_METHOD(Memcached, addserver, const String& host, int port,
@@ -1179,7 +1254,9 @@ class MemcachedExtension : public Extension {
     HHVM_ME(Memcached, replacebykey);
     HHVM_ME(Memcached, casbykey);
     HHVM_ME(Memcached, deletebykey);
+    HHVM_ME(Memcached, increment);
     HHVM_ME(Memcached, incrementbykey);
+    HHVM_ME(Memcached, decrement);
     HHVM_ME(Memcached, decrementbykey);
     HHVM_ME(Memcached, addserver);
     HHVM_ME(Memcached, getserverlist);
--- a/hphp/runtime/ext/memcached/ext_memcached.php
+++ b/hphp/runtime/ext/memcached/ext_memcached.php
@@ -204,10 +204,10 @@ class Memcached {
    *
    * @return int - Returns item's new value on success.
    */
-  public function decrement(mixed $key,
-                            mixed $offset = 1,
-                            mixed $initial_value = 0,
-                            mixed $expiry = 0): mixed {
+  public function decrement(string $key,
+                            int $offset = 1,
+                            int $initial_value = 0,
+                            int $expiry = 0): mixed {
     return $this->decrementByKey('', $key, $offset, $initial_value, $expiry);
   }
 
@@ -472,12 +472,11 @@ class Memcached {
    *
    * @return int - Returns new item's value on success.
    */
-  public function increment(mixed $key,
-                            mixed $offset = 1,
-                            mixed $initial_value = 0,
-                            mixed $expiry = 0): mixed {
-    return $this->incrementByKey('', $key, $offset, $initial_value, $expiry);
-  }
+  <<__Native>>
+  public function increment(string $key,
+                            int $offset = 1,
+                            int $initial_value = 0,
+                            int $expiry = 0): mixed;
 
   /**
    * Increment numeric item's value, stored on a specific server
--- a/hphp/runtime/vm/native.h
+++ b/hphp/runtime/vm/native.h
@@ -104,7 +104,7 @@ class Object;
  * These macros only differ in the following ways:
  * - They accept a classname in addition to the function name
  * - The registered name of the function is "ClassName->FunctionName"
- * - Prototypes include a prepended const Object& parameter (named this_)
+ * - Prototypes include a prepended ObjectData* const parameter (named this_)
  */
 #define HHVM_MN(cn,fn) c_ ## cn ## _ni_ ## fn
 #define HHVM_METHOD(cn, fn, ...) \
